<p><strong>Depth First Search</strong> is used to find a path between two nodes in <mark>undirected or directed, unweighted graphs</mark></p>
<p><mark>The path is found by <strong>DFS</strong> is uncertain the shortest.</mark></p>
<div class="space-60">
    <table>
        <tr>
            <td><strong>graph</strong></td>
            <td><strong>&nbsp;&nbsp;:&nbsp;&nbsp;&nbsp;&nbsp;</strong></td>
            <td><p>The list of edges in the graph</p></td>
        </tr>
        <tr>
            <td><strong>visited</strong></td>
            <td><strong>&nbsp;&nbsp;:&nbsp;&nbsp;&nbsp;&nbsp;</strong></td>
            <td>
                <p>
                    The list of visited nodes. <br>
                    Because graph may contain cycles, we need to save the visited node for checking
                </p>
            </td>
        </tr>
        <tr>
            <td><strong>path</strong></td>
            <td><strong>&nbsp;&nbsp;:&nbsp;&nbsp;&nbsp;&nbsp;</strong></td>
            <td><p>The list for tracking path. From this list, we can trace the path between 2 nodes.</p></td>
        </tr>
        <tr>
            <td><strong>queue</strong></td>
            <td><strong>&nbsp;&nbsp;:&nbsp;&nbsp;&nbsp;&nbsp;</strong></td>
            <td>
                <p>
                    When we go to a node, we push its children to the queue. <br>
                    The algorithm stops when the queue is empty.
                </p>
            </td>
        </tr>
    </table>
</div>
<pre>
    def DFS(graph, root = None):
        path = {}
        stack = []
        visited = {}
        
        stack.append(root)
        visited[root] = True
        
        while len(stack):
            node = stack.pop()
            
            if node in graph:
                for child in graph[node]:
                    if child not in visited:
                        path[child] = node
                        stack.append(child)
                        visited[child] = True
                    
        return path
</pre>