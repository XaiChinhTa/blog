<h3>ECMA Script</h3>
<div class="space-40">
	<p>
		Trước khi có ES thì có một đặc tả ngôn ngữ kịch bản được phát triển bởi Brendan Eich của Netscape và nó có tên là Mocha. Sau đó nó được đổi tên thành LiveScript và cuối cùng là Javascript.
	</p>
	<p>
		Netscape chuyển Javascript tới ECMA International để làm công tác chuẩn hoá và viết đặc tả, được gọi là ECMA-262, bắt đầu vào tháng 11, 1996. Và cái tên ECMAScript được hình thành từ đây bởi
		sự thoả thuận giữa những công ty đang tham gia vào quá trình chuẩn hóa
	</p>
	<p>
		ECMA Script (hay ES) là một đặc tả ngôn ngữ kịch bản được tiêu chuẩn hóa bởi <strong>ECMA International</strong> thông qua <strong>ECMA-262</strong>. Nó được tạo ra để tiêu chuẩn hóa
		JavaScript. Ngoài JavaScript, vẫn có những ngôn ngữ kịch bản khác tuân thủ theo ECMA Script như <strong>JScript</strong> và <strong>ActionScript</strong>.
	</p>
</div>
<br />
<h3>JavaScript Engine</h3>
<div class="space-40">
	<p>
		JavaScript Engine là một chương trình thực thi mã nguồn (Interpreter) được viết theo một phiên bản tiêu chuẩn của ngôn ngữ ECMA Script. Vì ECMA Script (ES) là đặc tả được tiêu chuẩn
		hóa(standardized specification) của JavaScript nên ECMAScript Engine là một tên gọi khác của JavaScript Engine.
	</p>
	<p>
		Các JavaScript Engine thường được phát triển bởi các nhà cung cấp trình duyệt. Như V8 (Chrome), SpiderMonkey (FireFox), JavaScriptCore (Safari), Chakra (Microsoft Edge). Trong trình duyệt,
		JavaScript Engine chạy phối hợp với Rendering Engine thông qua DOM(Document Object Model).
	</p>
	<p>
		Hiện nay, việc sử dụng các JavaScript Engine không còn bị giới hạn ở các trình duyệt. Như <strong>V8</strong> là một JavaScript Engine được phát triển bởi Google, được sử dụng trong trình
		duyệt Chrome và cả trong Node.js(Runtime System).
	</p>
	<br />
</div>
<h3>Resident Set in V8</h3>
<div class="space-40">
	<p>Trong V8, Một chương trình đang chạy luôn được thể hiện thông qua một số không gian được phân bổ trong bộ nhớ. Không gian này được gọi là <strong>Resident Set</strong></p>
	<br />
	<img src="/assets/imgs/resident-set.png" />
	<br />
	<br />
	<br />
	<p>Resident Set gồm 2 thành phần chính:</p>
	<div class="space-40">
		<p>
			<span class="point">&#9899;</span> <strong>Call Stack</strong> (<strong>Memory Stack</strong>) là nơi code được thực thi cũng như lưu trữ dữ liệu tĩnh bao gồm primitive value và con trỏ
			đến các Object được lưu trên Heap và các con trỏ xác định control flow (luồng chạy) của chương trình.
		</p>
		<p>
			<span class="point">&#9899;</span> <strong>Memory Heap</strong> là nơi lưu trữ Objects, Strings và
			<strong><a href="https://www.tutorialsteacher.com/javascript/closure-in-javascript" target="blank">Closures</a></strong
			>.
		</p>
		<br />
		<div class="slider no-focused" tabindex="0">
			<img class="slider-item" src="/assets/imgs/under_the_hood_slide_0.jpg" />
			<img class="slider-item" src="/assets/imgs/under_the_hood_slide_1.jpg" style="display: none;" />
			<img class="slider-item" src="/assets/imgs/under_the_hood_slide_2.jpg" style="display: none;" />
			<img class="slider-item" src="/assets/imgs/under_the_hood_slide_3.jpg" style="display: none;" />
			<img class="slider-item" src="/assets/imgs/under_the_hood_slide_4.jpg" style="display: none;" />
			<img class="slider-item" src="/assets/imgs/under_the_hood_slide_5.jpg" style="display: none;" />
			<img class="slider-item" src="/assets/imgs/under_the_hood_slide_6.jpg" style="display: none;" />
			<img class="slider-item" src="/assets/imgs/under_the_hood_slide_7.jpg" style="display: none;" />
			<img class="slider-item" src="/assets/imgs/under_the_hood_slide_8.jpg" style="display: none;" />
			<img class="slider-item" src="/assets/imgs/under_the_hood_slide_9.jpg" style="display: none;" />
			<img class="slider-item" src="/assets/imgs/under_the_hood_slide_10.jpg" style="display: none;" />
			<img class="slider-item" src="/assets/imgs/under_the_hood_slide_11.jpg" style="display: none;" />
			<img class="slider-item" src="/assets/imgs/under_the_hood_slide_12.jpg" style="display: none;" />
			<img class="slider-item" src="/assets/imgs/under_the_hood_slide_13.jpg" style="display: none;" />
			<img class="slider-item" src="/assets/imgs/under_the_hood_slide_14.jpg" style="display: none;" />
		</div>
	</div>
</div>
<br />
<br />
<br />
<h3>Concurrency & Event Loop</h3>
<div class="space-40">
	<p>
		<strong><i>Javascript is a single threaded single concurrent language</i> - ngôn ngữ đồng thời đơn luồng</strong>. Điều này có nghĩa là JavaScript chỉ có thể xử lý 1 tác vụ tại 1 thời điểm. Ở
		ví dụ trên, chúng ta đã thấy Call Stack và Heap hoạt động, chỉ có duy nhất một đoạn code được thực thi tại 1 thời điểm. Vậy làm thế nào để JavaScript có thể xử lý những tác vụ bất đồng bộ ?
	</p>
	<br />
	<p>
		Thực ra, ngoài <strong>Call Stack</strong>, <strong>Memory Heap</strong>, chúng ta sẽ được cung cấp các <strong>Web API</strong> bởi Web Browser như setTimeout, setInterval, ... Còn trong môi
		trường Server Side như <strong>Node JS</strong>, chúng ta có một tập các <strong>C++ API</strong>. Những API đó sẽ giúp chúng ta làm việc hiệu quả hơn với Thread vì vậy Thread sẽ bị che đi
		trong code C++.
	</p>
	<br />
	<p>
		Vì Web API (C++ API) được xem như một library bổ sung nên nó sẽ không thể thay đổi mã nguồn cũng như không thể làm việc trực tiếp với <strong>Call Stack</strong>. Đây là lúc
		<strong>Task Queue</strong>(<strong>Callback Queue</strong>) xuất hiện.
	</p>
	<br />
	<p>
		Bất kỳ Web API (C++ API) nào cũng sẽ đưa callback vào Task Queue khi nó hoàn thành. Lúc này, nhiệm vụ của <strong>Event Loop</strong> là <i><u>đợi đến khi Call Stack rỗng</u></i> và lấy những
		thứ trên Task Queue bỏ vào Call Stack.
	</p>
	<br />
	<p><strong>Call Stack</strong>, <strong>Memory Heap</strong> và <strong>Callback Queue</strong> tạo thành <strong>JavaScript Concurrency Model</strong> dựa trên <strong>Event Loop</strong>.</p>
	<br />
	<h4>Note</h4>
	<div class="space-40">
		<p>
			Trên browser, ngoài Callback Queue, chúng ta còn có <strong>Render Queue</strong>. Render Queue có độ ưu tiên cao hơn Callback Queue nên nó sẽ được Event Loop đưa vào Call Stack trước
			Callback Queue.
		</p>
	</div>
</div>
